# 보고서 제목
* 이성진

### 목차

* 시간 복잡도의 정의와 필요성
* Big O 표기법의 개념과 상황별 예시
* 문제01 코드의 시간 복잡도 분석
* 문제02 코드의 시간 복잡도 분석
* 병목 현상 분석 및 최적화 방안


#### 시간 복잡도의 정의와 필요성
* 정의 : 시간복잡도는 다양한 풀이법(알고리즘) 중에 어느 것이 더 효율적인지를 판별하기 위해 만든 것이다.

* 필요성 <br>
1.성능 예측 2. 효율적인 알고리즘 선택

#### Big O 표기법의 개념과 상황별 예시
프로그램은 대부분 입력값이 최선의 경우일 가능성이 적을뿐더러 항상 최악의 경우를 대비해야 하기 때문에 시간 복잡도를 확인할 때 빅 오 표기법을 사용합니다. <br>

1. O(1), 상수
입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리고 데이터의 양이 증가해도 성능에 거의 영향을 미치지 않습니다. 예제는 Stack의 Push, Pop이 대표적입니다.

2. O(㏒ N), 로그
입력 데이터의 크기가 커질수록 처리 시간이 로그만큼 짧아집니다. 예를 들어 데이터가 10배가 되면 처리 시간은 2배가 됩니다. 예제는 이진트리가 대표적이며 재귀가 순기능으로 이루어지는 경우에도 해당됩니다.

3. O(N), 선형
입력 데이터의 크기에 비례해 처리 시간이 증가합니다. 예를 들어 데이터가 10배가 되면 처리 시간도 10배가 됩니다. 예제는 for 문이 대표적입니다.

4. O(N ㏒ N), 선형 로그
입력 데이터가 많아질수록 처리 시간이 로그 배만큼 더 늘어납니다. 예를 들어 데이터가 10배가 되면 처리 시간은 약 20배가 됩니다. 예제는 퀵 정렬(Quick Sort), 합병 정렬(Merge Sort), 힙 정렬(Heap Sort)이 대표적입니다.

5. O(N²), 다항
입력 데이터가 많아질수록 처리시간이 급수적으로 늘어납니다. 예를 들어 데이터가 10배가 되면 처리 시간은 최대 100배가 됩니다. 예제는 삽입 정렬(Insertion Sort), 버블 정렬(Bubble Sort), 선택 정렬(Selection Sort), 이중 for 문이 대표적입니다.

6. O(2ⁿ), 지수
입력 데이터가 많아질수록 처리시간이 기하급수적으로 늘어납니다. 예제는 피보나치(Fibonacci) 수열이 대표적이며 재귀가 역기능으로 이루어질 경우에도 해당됩니다.

#### 문제01 코드의 시간 복잡도 분석
시간복잡도: O(n²)

입력 길이 n이 커지면 실행 시간이 급격히 증가함.

#### 문제02 코드의 시간 복잡도 분석
입력 문자열 길이 n에 대해 선형 시간 O(n) 입니다.

입력 크기에 비례해서 시간이 늘어나므로 효율적이라고 볼 수 있습니다.

#### 병목 현상 분석 및 최적화 방안
* 문제 1번
1. 병목 현상 분석 : <br>
   주요 작업들: 문자열을 한 글자씩 배열에 저장 (O(n)) , 배열을 역순으로 push (O(n))
2. 최적화 방안 <br>
   문자 분리 배열 없이 직접 push
* 문제 2번 
1. 병목 현상 분석 : <br>
   중복 확인하는 이중 루프
2. 최적화 방안 <br>
   해시맵(HashMap) 혹은 배열로 빈도 계산 (O(n))

### 참고사이트
* 마크다운 작성법 : https://gist.github.com/ihoneymon/652be052a0727ad59601
* 시간복잡도 참고 : https://velog.io/@skynet/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%EC%A4%91%EC%9A%94%ED%95%A0%EA%B9%8C
* 빅오표기법 참고 : https://aiday.tistory.com/54
* 시간복잡도 계산 : chatgpt